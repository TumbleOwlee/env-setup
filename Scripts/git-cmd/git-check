#!/bin/env python3

# for exit
import sys
# subprocess for ssh execution
import subprocess
# compile for input parsing
import argparse
# Terminal for colorization
from blessed import Terminal
# Rich terminal
from rich.console import Console
from rich.table import Table
# Regex
import re

# Customize theme of inquirer
term = Terminal()

# console for rich
console = Console()


# Helper for info log
def info(msg: str):
    print(f"[{term.aqua}+{term.normal}] {msg}")


# Helper for error log
def error(msg: str):
    print(f"[{term.red}E{term.normal}] {msg}")


# Helper for success log
def success(msg: str):
    print(f"[{term.green}!{term.normal}] {msg}")


# Helper for command execution
def run_cmd(args: [str]):
    proc = subprocess.run(args, stdout=subprocess.PIPE, text=True)
    return proc.returncode, proc.stdout


def get_sorted_branches(since: str | None, remote: bool):
    flag = "-r" if remote else "-l"
    code, output = run_cmd(["git", "branch", flag, "--sort=committerdate",
                           "--format=%(committerdate:short) %(refname:short)"])
    if code != 0:
        error("Failed to retrieve all branch names.")
        sys.exit(1)

    branches = dict()
    for line in output.splitlines():
        if line.startswith('*'):
            line = line[1:]
        branch = line.strip()
        b = branch.split(' ')
        if b[0] > since:
            if remote:
                n = b[1].split('/')[0]
                branches[b[1][len(n) + 1:]] = (b[0], n)
            else:
                branches[b[1]] = (b[0], None)
    return branches


def get_all_known_branches(since: str | None):
    branches = get_sorted_branches(since, False)
    remote_branches = get_sorted_branches(since, True)

    combined = []
    for k in branches:
        v = branches[k]
        if k in remote_branches:
            if v[0] > remote_branches[k][0]:
                combined.append((v[0], remote_branches[k][1], k))
            else:
                combined.append(
                    (remote_branches[k][0], remote_branches[k][1], k))
        else:
            combined.append((v[0], v[1], k))

    for k in remote_branches:
        v = remote_branches[k]
        if k not in branches:
            combined.append((v[0], v[1], k))

    return sorted(combined, key=lambda value: value[0], reverse=True)


def get_all_merged_branches_of(branch: str):
    if isinstance(branch, str):
        code, output = run_cmd(["git", "branch", "-l", "--merged", branch])
        if code != 0:
            error("Failed to retrieve all merged branch names.")
            sys.exit(1)

        # Get all branch names
        merged = []
        for line in output.splitlines():
            b = line.strip()
            merged.append(b)

        code, output = run_cmd(["git", "branch", "-r", "--merged", branch])
        if code != 0:
            error("Failed to retrieve all merged branch names.")
            sys.exit(1)

        # Get all branch names
        for line in output.splitlines():
            b = line.strip()
            merged.append(b)
        return merged
    else:
        merged = []
        for b in branch:
            merged.append((b, get_all_merged_branches_of(b)))
        return merged


def create_table(names: [str]):
    table = Table(show_header=True, header_style="bold cyan")
    table.add_column("Jira ID", justify="left")
    table.add_column("Date", justify="center")
    table.add_column("Remote", justify="center")
    table.add_column("Branch", justify="left")
    for n in names:
        table.add_column(n, justify="center")
    return table


def display_table(table: Table, branches: [(str, str | None, str)], merged: [(str, [str])], ignore: bool):
    pattern = '([A-Z]+-[0-9]+)'
    for b in branches:
        g = re.search(pattern, b[2])
        if g is None and ignore:
            continue
        tag = "[yellow]" + g.group() + \
            "[/yellow]" if g is not None else '[#444444]None[/#444444]'

        row = [tag, b[0], b[1], b[2]]
        for m in merged:
            origin = (b[1] + "/") if b[1] is not None else ""
            if (origin + b[2]) in m[1]:
                row.append("[green]Yes[/green]")
            else:
                row.append("[red]No[/red]")
        table.add_row(*row)
    console.print(table)


def get_all_branches_with_remote():
    code, output = run_cmd(
        ["git", "for-each-ref", "--format=%(refname:short) %(upstream:short)"])
    if code != 0:
        error("Failed to retrieve assigned remote origins for branches.")
        sys.exit(1)

    origins = dict()
    for line in output.splitlines():
        b = line.strip().split()
        if len(b) > 1:
            origins[b[0]] = b[1]
    return origins


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Display table showing if branches are merged into given branches.")
    parser.add_argument("-s", "--since", type=str,
                        help="Only show branches newer than the given timestamp YYYY-MM-DD.")
    parser.add_argument("-i", "--ignore", action="store_true",
                        help="Ignore all branches without an associated tag.")
    parser.add_argument(
        "BRANCH", help="Branch name to check against.", type=str, nargs='+')
    args = parser.parse_args()

    branches = get_all_known_branches(args.since)
    merged = get_all_merged_branches_of(args.BRANCH)
    table = create_table([args.BRANCH] if isinstance(
        args.BRANCH, str) else args.BRANCH)

    display_table(table, branches, merged, args.ignore)
