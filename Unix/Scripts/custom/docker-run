#!/bin/bash
#
# Requirements:
#  - An executable script `.commands` in one of the following locations.
#      - `$GIT_ROOT/`
#      - `$GIT_ROOT/.devcontainer/`
#      - `~/.local/share/docker-run/`
#    If the `.commands` script is located in the `$GIT_ROOT`, it takes two arguments:
#      1. The docker-compose target
#      2. The arguments as given to this script
#    If the `.commands` script is located in `~/.local/share/docker-run/`, the script takes
#    an additional parameter to provide information about the repository:
#      1. The path to the current git repository
#      2. The docker-compose target
#      3. The arguments as given to this script
#    The script has to print commands to manipulate the environment, working directory and specify
#    commands to execute to stdout. The following outputs are used:
#      - `ENV:$VAR=$VALUE` to set an environment variable
#      - `DIR:$PATH` to set the working directory
#      - `CMD:$COMMAND` to set the command to exeucte
#    The commands are executed one by one. Thus if you want to execute commands in seperate
#    directories, you can use something like this:
#    ```bash
#      DIR:$PATH1
#      CMD:$COMMAND1
#      DIR:$PATH2
#      CMD:$COMMAND2
#    ```
#    This way $COMMAND1 is executed in $PATH1 and $COMMAND2 in $PATH2.
#  - A `docker-compose.yml` has to be located in the `$GIT_ROOT`, `$GIT_ROOT/.devcontainer`,
#    `$GIT_ROOT/local` or `~/.local/share/docker-run/` and has to configure three services for
#    full support, each one specifying a different platform:
#      * `linux/amd64`
#      * `linux/arm/v7`
#      * `linux/arm64/v8`
#
#  Afterwards, simply create two symbolic links `arm-run` and `arm8-run` or simply use
#  `docker-run install-links` and be ready to run any command in an armv7, armv8 or amd64
#
#  At runtime the information about running docker containers managed by the script is located
#  at /tmp/docker-run
RED="\e[31m"
GREEN="\e[32m"
YELLOW="\e[33m"
BLUE="\e[34m"
RESET="\e[0m"

# Install symbolic links
if [ "$1" == "install-links" ]; then
    SCRIPT_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd)
    if [ ! -f "$SCRIPT_DIR/arm-run" ]; then
        echo -e "$YELLOW[!]$RESET Install symbolic link '$BLUE$SCRIPT_DIR/arm-run$RESET'"
        ln -sf "$SCRIPT_DIR/docker-run" "$SCRIPT_DIR/arm-run"
        chmod +x "$SCRIPT_DIR/arm-run"
    else
        echo -e "$YELLOW[$GREEN!$YELLOW]$RESET Symbolic links '$BLUE$SCRIPT_DIR/arm-run$RESET' already present."
    fi

    if [ ! -f "$SCRIPT_DIR/arm8-run" ]; then
        echo -e "$YELLOW[!]$RESET Install symbolic link '$BLUE$SCRIPT_DIR/arm8-run$RESET'"
        ln -sf "$SCRIPT_DIR/docker-run" "$SCRIPT_DIR/arm8-run"
        chmod +x "$SCRIPT_DIR/arm8-run"
    else
        echo -e "$YELLOW[$GREEN!$YELLOW]$RESET Symbolic links '$BLUE$SCRIPT_DIR/arm8-run$RESET' already present."
    fi
    exit 0
fi

# Remove quotes
unquote() {
    VALUE="$@"
    if [ -z "$(echo $VALUE | cut -f1 -d"'")" ]; then
        echo $(echo $VALUE | cut -f2- -d"'" | rev | cut -f2- -d"'" | rev)
    elif [ -z "$(echo $VALUE | cut -f1 -d'"')" ]; then
        echo $(echo $VALUE | cut -f2- -d'"' | rev | cut -f2- -d'"' | rev)
    else
        echo $@
    fi
}

# Yaml parser to XPath
parse_yaml() {
    FILENAME=$1

    if [ -z "$FILENAME" ]; then
        echo -e "${RED}Abort:$RESET No file specified"
        exit 1
    fi

    PREV_INDENT=0
    XPATH=""
    LAST_XPATH=""

    while IFS= read -r line; do
        INDENT=0

        STRIPPED="$(echo $line)"
        if [[ "$STRIPPED" =~ ^-.* ]]; then
            ITEM="$(echo $(echo $STRIPPED | cut -f2- -d'-'))"
            echo "$LAST_XPATH=$(unquote $ITEM)"
        else
            # Get indentation level
            while [ -z "$(echo "$line" | cut -f$((INDENT + 1)) -d' ')" ]; do
                INDENT=$(($INDENT + 1))
            done

            if [ $INDENT -ne $PREV_INDENT ]; then
                # Remove last part
                if [ $INDENT -lt $PREV_INDENT ]; then
                    XPATH=$(echo $XPATH | rev | cut -f2- -d'.' | rev)
                elif [ $INDENT -gt $PREV_INDENT ]; then
                    XPATH=$LAST_XPATH
                fi
                PREV_INDENT=$INDENT
            fi

            LABEL="$(echo $line | cut -f1 -d':')"
            VALUE="$(echo $(echo $line | cut -f2- -d':'))"
            if [ ! -z "$VALUE" ]; then
                echo "${XPATH}.${LABEL}=$(unquote $VALUE)"
            fi
            LAST_XPATH="${XPATH}.${LABEL}"
        fi
    done < <(cat $FILENAME)
}

# Since we utilize the symlink arm-run to execute commands in an armv7
# environment, we check for the executable name to determine the container
# to use.
NAME=$(basename $0)

# Initialize variables
WORKDIR=$(pwd)
CUR_DIR=$(pwd)

# Use bake for better performance
export COMPOSE_BAKE=true

# Detect git repository root
while [ ! -z "${CUR_DIR}" ] && [ ! -d "${CUR_DIR}/.git" ]; do
    CUR_DIR=$(dirname ${CUR_DIR})
done

# Get directory containing given file
locate_file() {
    if [ -f "$CUR_DIR/.devcontainer/$1" ]; then
        echo "$CUR_DIR/.devcontainer"
    elif [ -f "$CUR_DIR/local/$1" ]; then
        echo "$CUR_DIR/local"
    elif [ -f "$CUR_DIR/$1" ]; then
        echo "$CUR_DIR"
    elif [ -f "$WORKDIR/$1" ]; then
        echo "$WORKDIR"
    fi
}

DOCKER_COMPOSE_DIR="$(locate_file docker-compose.yml)"
if [ ! -z "$DOCKER_COMPOSE_DIR" ]; then
    echo -e "$YELLOW[!]$RESET Use ${GREEN}docker-compose.yml${RESET} in $BLUE$DOCKER_COMPOSE_DIR$RESET"
elif [ -f "$HOME/.local/share/docker-run/docker-compose.yml" ]; then
    DOCKER_COMPOSE_DIR="$HOME/.local/share/docker-run"
    echo -e "$YELLOW[!]$RESET Use ${GREEN}docker-compose.yml${RESET} in $BLUE$DOCKER_COMPOSE_DIR$RESET"
else
    echo -e "$RED[E]$RESET Unable to locate '${BLUE}docker-compose.yml$RESET'" >&2
    exit 1
fi
CONTAINER_NAME="$(basename $WORKDIR)"

COMMANDS_DIR="$(locate_file .commands)"
if [ ! -z "$COMMANDS_DIR" ]; then
    echo -e "$YELLOW[!]$RESET Use ${GREEN}.commands${RESET} in $BLUE$COMMANDS_DIR$RESET"
else
    if [ -f "$HOME/.local/share/docker-run/.commands" ]; then
        GLOBAL_COMMANDS_DIR="$HOME/.local/share/docker-run"
        echo -e "$YELLOW[!]$RESET Use ${GREEN}.commands${RESET} in ${BLUE}$GLOBAL_COMMANDS_DIR${RESET}"
    fi
fi

USER_COMMANDS_DIR="$(locate_file .user-commands)"
if [ ! -z "$USER_COMMANDS_DIR" ]; then
    echo -e "$YELLOW[!]$RESET Use ${GREEN}.user-commands${RESET} in $BLUE$USER_COMMANDS_DIR$RESET"
fi

# Specify compose target platform
if [ "$NAME" == "arm-run" ]; then
    DOCKER_COMPOSE_PLATFORM="linux/arm/v7"
elif [ "$NAME" == "arm8-run" ]; then
    DOCKER_COMPOSE_PLATFORM="linux/arm64/v8"
else
    DOCKER_COMPOSE_PLATFORM="linux/amd64"
fi

DOCKER_COMPOSE_TARGET=$(parse_yaml "$DOCKER_COMPOSE_DIR/docker-compose.yml" | grep platform | grep $DOCKER_COMPOSE_PLATFORM | cut -f3 -d'.')

GIT_DIR=$CUR_DIR
GIT_BASENAME=$(echo "P$GIT_DIR" | sed 's/\//-/g' | tr '[:upper:]' '[:lower:]')

CONTAINER_ID=$(docker container ls | grep "$GIT_BASENAME-$DOCKER_COMPOSE_TARGET" | cut -f1 -d' ')
if [ ! -z "$CONTAINER_ID" ]; then
    if [ ! -z "$1" ] && [ "$1" == "stop" ]; then
        echo -e "$YELLOW[!]$RESET Stop running container $BLUE$CONTAINER_ID$RESET"
        docker stop $CONTAINER_ID &>/dev/null
        exit $?
    elif [ ! -z "$1" ] && [ "$1" == "rebuild" ]; then
        echo -e "$YELLOW[!]$RESET Stop running container $BLUE$CONTAINER_ID$RESET"
        docker stop $CONTAINER_ID &>/dev/null
    elif [ ! -f "/tmp/docker-run" ]; then
        echo -e "$YELLOW[!]$RESET Stop running container $BLUE$CONTAINER_ID$RESET"
        docker stop $CONTAINER_ID &>/dev/null
    else
        DIR="$(parse_yaml /tmp/docker-run | grep "$DOCKER_COMPOSE_PLATFORM-$DOCKER_COMPOSE_TARGET-$GIT_BASENAME=" | cut -f2- -d'=')"
        if [ -z "$DIR" ] || [ "$DIR" != "$GIT_DIR" ]; then
            echo -e "$YELLOW[!]$RESET Stop running container $BLUE$CONTAINER_ID$RESET"
            docker stop $CONTAINER_ID &>/dev/null
        fi
    fi
elif [ ! -z "$1" ] && [ "$1" == "stop" ]; then
    echo -e "$YELLOW[!]$RESET No container running."
    exit 0
fi

if [ ! -z "$1" ] && [ "$1" == "rebuild" ]; then
    CONTAINER_ID=$(docker container ls -a | grep "$GIT_BASENAME-$DOCKER_COMPOSE_TARGET" | cut -f1 -d' ')
    if [ ! -z "$CONTAINER_ID" ]; then
        echo -e "$YELLOW[!]$RESET Run: '${BLUE}docker container rm $CONTAINER_ID$RESET'"
        docker container rm $CONTAINER_ID 1>/dev/null || exit 1
    fi

    echo -e "$YELLOW[!]$RESET Run: '${BLUE}GIT_DIR="$GIT_DIR" docker compose -f \"$DOCKER_COMPOSE_DIR/docker-compose.yml\" -p \"$GIT_BASENAME\" build --no-cache $DOCKER_COMPOSE_TARGET$RESET'"
    (cd $GIT_DIR && GIT_DIR="$GIT_DIR" docker compose -f "$DOCKER_COMPOSE_DIR/docker-compose.yml" -p "$GIT_BASENAME" build --no-cache $DOCKER_COMPOSE_TARGET) && exit 0 || exit 1
fi

# Get Git branch
REGEX="([A-Z]+-[0-9]+)"
BRANCH="$(/usr/bin/git branch --show-current)"

if [[ $BRANCH =~ $REGEX ]]; then
    BUILD_DIR="${BASH_REMATCH[1]}"
else
    BUILD_DIR=$(echo "${BRANCH}" | tr '[:upper:]' '[:lower:]' | sed 's/[\/_]/-/g')
fi

if [ ! -f "/tmp/docker-run" ]; then
    echo "$DOCKER_COMPOSE_PLATFORM-$DOCKER_COMPOSE_TARGET-$GIT_BASENAME: $GIT_DIR" >> /tmp/docker-run
else
    cat /tmp/docker-run | grep -v "$DOCKER_COMPOSE_PLATFORM-$DOCKER_COMPOSE_TARGET-$GIT_BASENAME:" > /tmp/docker-run-tmp
    mv /tmp/docker-run-tmp /tmp/docker-run
    echo "$DOCKER_COMPOSE_PLATFORM-$DOCKER_COMPOSE_TARGET-$GIT_BASENAME: $GIT_DIR" >> /tmp/docker-run
fi

# Get container id
CONTAINER_ID=$(docker container ls | grep "$GIT_BASENAME-$DOCKER_COMPOSE_TARGET" | cut -f1 -d' ')

# Abort if container isn't running
if [ -z "$CONTAINER_ID" ]; then
    if [ $? -ne 0 ]; then
        echo -e "$RED[E]$RESET Failed to run '${BLUE}docker run --rm --privileged multiarch/qemu-user-static --reset -p yes$RESET'"
        exit 1
    fi
    docker run --rm --privileged multiarch/qemu-user-static --reset -p yes &>/dev/null

    echo -en "$YELLOW[!]$RESET Run: '${BLUE}GIT_DIR="$GIT_DIR" docker compose -f \"$DOCKER_COMPOSE_DIR/docker-compose.yml\" -p \"$GIT_BASENAME\" up -d \"$DOCKER_COMPOSE_TARGET\"$RESET'"
    SECONDS=0
    while IFS= read -r line; do
        echo -en "\r$YELLOW[!]$RESET Run: '${BLUE}GIT_DIR="$GIT_DIR" docker compose -f \"$DOCKER_COMPOSE_DIR/docker-compose.yml\" -p \"$GIT_BASENAME\" up -d \"$DOCKER_COMPOSE_TARGET\"$RESET' ${SECONDS}s    "
    done < <(cd $GIT_DIR && GIT_DIR="$GIT_DIR" docker compose -f "$DOCKER_COMPOSE_DIR/docker-compose.yml" -p "$GIT_BASENAME" up -d $DOCKER_COMPOSE_TARGET 2>&1)
    echo ""
    if [ $? -ne 0 ]; then
        echo -e "$RED[!]$RESET Failed to run: '${BLUE}GIT_DIR="$GIT_DIR" docker compose -f \"$DOCKER_COMPOSE_DIR/docker-compose.yml\" -p \"$GIT_BASENAME\" up -d \"$DOCKER_COMPOSE_TARGET\"$RESET'"
        exit 1
    fi
fi

CONTAINER_ID=$(docker container ls | grep "$GIT_BASENAME-$DOCKER_COMPOSE_TARGET" | cut -f1 -d' ')
echo -e "$YELLOW[!]$RESET Use ${GREEN}container id${RESET}: '$BLUE$CONTAINER_ID$RESET'"

# Detect relative path from repository root
if [ ! -z ${CUR_DIR} ]; then
    CUR_DIR="${WORKDIR##${CUR_DIR}}"
fi

if [ ! -z "$1" ]; then
    INPUT=""

    if [ ! -z "$GLOBAL_COMMANDS_DIR" ]; then
        INPUT="$GLOBAL_COMMANDS_DIR/.commands"
        REPOSITORY="$GIT_DIR"
    fi

    if [ ! -z "$COMMANDS_DIR" ]; then
        INPUT="$COMMANDS_DIR/.commands"
    fi

    if [ ! -z "$USER_COMMANDS_DIR" ]; then
        INPUT="$USER_COMMANDS_DIR/.user-commands"
    fi

    CMD_EXECUTED=0
    ENV_ARGS=()
    ENV_ARGS_BARE=()
    COLORS=("$RED" "$YELLOW" "$GREEN")
    COLOR_SELECTION=0
    while IFS= read -u 10 line; do
        if [ ! -z "$line" ]; then
            if [[ "$line" =~ ^ENV:.* ]]; then
                ENV_ARGS+=("-e ${line#"ENV:"}")
                ENV_ARGS_BARE+=("${line#"ENV:"}")
            elif [[ "$line" =~ ^DIR:.* ]]; then
                CUR_DIR="$(echo ${line#"DIR:"})"
            elif [[ "$line" =~ ^CMD:.* ]]; then
                OUTPUT=0
                COLOR="${COLORS[$COLOR_SELECTION]}"
                eval set -- "${line#"CMD:"}"
                echo ""
                echo -e "$COLOR┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────────$RESET"
                echo -e "$COLOR│$RESET ${YELLOW}Run:$RESET '$BLUE$@$RESET'"
                ENV_CHECK="${ENV_ARGS_BARE[@]}"
                if [ ! -z "${ENV_CHECK}" ]; then
                    echo -e "$COLOR│$RESET ${YELLOW}Environment:$RESET'"
                    for ENV in "${ENV_ARGS_BARE[@]}"; do
                        echo -e "$COLOR│$RESET ${YELLOW}    -$RESET $BLUE${ENV}$RESET"
                    done
                fi
                if [ ! -z "${CUR_DIR}" ]; then
                    echo -e "$COLOR│$RESET ${YELLOW}Working Directory:$RESET '$BLUE/git/${CUR_DIR}$RESET'"
                fi
                echo -en "$COLOR└───┬────────────────────────────────────────────────────────────────────────────────────────────────────────────────$RESET"
                while IFS= read -d '' -n 1 line; do
                    if [ $OUTPUT -eq 0 ]; then
                        echo -en "\n\r    $COLOR│$RESET "
                        OUTPUT=1
                    fi
                    if [ ! -z "$line" ] &&  [[ "$line" == $'\r' ]]; then
                        echo -en "$line    $COLOR│$RESET "
                    elif [ ! -z "$line" ] &&  [[ "$line" == $'\n' ]]; then
                        echo -en "$line    $COLOR│$RESET "
                    else
                        echo -en "$line"
                    fi
                done < <(docker exec -e "TZ=Europe/Berlin" ${ENV_ARGS[@]} --workdir "/git/$CUR_DIR" $CONTAINER_ID "$@" 2>&1)
                if [ $OUTPUT -eq 1 ]; then
                    echo -e "\r$COLOR    └────────────────────────────────────────────────────────────────────────────────────────────────────────────────$RESET"
                else
                    echo -e "\r$COLOR└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────$RESET"
                fi

                COLOR_SELECTION=$(($COLOR_SELECTION + 1))
                if [ $COLOR_SELECTION -eq 3 ]; then
                    COLOR_SELECTION=0
                fi

                CMD_EXECUTED=1
            else
                echo""
                echo -e "${RED}[!]${RESET} Invalid input: '${RED}$line${RESET}'."
            fi
        fi
    done 10< <("$INPUT" "$REPOSITORY" "$DOCKER_COMPOSE_TARGET" "$1" 2>/dev/null)

    if [ $CMD_EXECUTED -eq 0 ]; then
        # Run given commandline in the container
        OUTPUT=0
        COLOR="$BLUE"

        echo -e "$COLOR┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────────$RESET"
        echo -e "$COLOR│$RESET ${YELLOW}Run:$RESET '$BLUE$@$RESET'"
        ENV_CHECK="${ENV_ARGS_BARE[@]}"
        if [ ! -z "${ENV_CHECK}" ]; then
            echo -e "$COLOR│$RESET ${YELLOW}Environment:$RESET'"
            for ENV in "${ENV_ARGS_BARE[@]}"; do
                echo -e "$COLOR│$RESET ${YELLOW}    -$RESET $BLUE${ENV}$RESET"
            done
        fi
        if [ ! -z "${CUR_DIR}" ]; then
            echo -e "$COLOR│$RESET ${YELLOW}Working Directory:$RESET '$BLUE/git/${CUR_DIR}$RESET'"
        fi
        echo -e "$COLOR└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────$RESET"
        eval "docker exec -e \"TZ=Europe/Berlin\" ${ENV_ARGS[@]} --workdir \"/git/$CUR_DIR\" -it $CONTAINER_ID $(printf '%q ' "$@")"
    else
        echo ""
    fi
else
    echo -e "${RED}[!]${RESET} No command specified."
fi
