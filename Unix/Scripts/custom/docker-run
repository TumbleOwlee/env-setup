#!/bin/bash
#
# Requirements:
#  - An executable script `.commands` in one of the following locations.
#      - `$GIT_ROOT/`
#      - `$GIT_ROOT/.devcontainer/`
#      - `~/.local/share/docker-run/`
#    If the `.commands` script is located in the `$GIT_ROOT`, it takes two arguments:
#      1. The docker-compose target
#      2. The arguments as given to this script
#    If the `.commands` script is located in `~/.local/share/docker-run/`, the script takes
#    an additional parameter to provide information about the repository:
#      1. The path to the current git repository
#      2. The docker-compose target
#      3. The arguments as given to this script
#    The script has to print commands to manipulate the environment, working directory and specify
#    commands to execute to stdout. The following outputs are used:
#      - `ENV:$VAR=$VALUE` to set an environment variable
#      - `DIR:$PATH` to set the working directory
#      - `CMD:$COMMAND` to set the command to exeucte
#    The commands are executed one by one. Thus if you want to execute commands in seperate
#    directories, you can use something like this:
#    ```bash
#      DIR:$PATH1
#      CMD:$COMMAND1
#      DIR:$PATH2
#      CMD:$COMMAND2
#    ```
#    This way $COMMAND1 is executed in $PATH1 and $COMMAND2 in $PATH2.
#  - A `docker-compose.yml` has to be located in the `$GIT_ROOT`, `$GIT_ROOT/.devcontainer`,
#    `$GIT_ROOT/local` or `~/.local/share/docker-run/` and has to configure three services for
#    full support, each one specifying a different platform:
#      * `linux/amd64`
#      * `linux/arm/v7`
#      * `linux/arm64/v8`
#
#  Afterwards, simply create two symbolic links `arm-run` and `arm8-run` or simply use
#  `docker-run install-links` and be ready to run any command in an armv7, armv8 or amd64
#
#  At runtime the information about running docker containers managed by the script is located
#  at /tmp/docker-run
RED="\e[31m"
GREEN="\e[32m"
YELLOW="\e[33m"
BLUE="\e[34m"
PURPLE="\e[35m"
CYAN="\e[36m"
RESET="\e[0m"

mkdir /tmp/docker-run &>/dev/null
rm /tmp/docker-run/tmp.* &>/dev/null

# Install symbolic links
if [ "$1" == "install-links" ]; then
    SCRIPT_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd)
    if [ ! -f "$SCRIPT_DIR/arm-run" ]; then
        echo -e "$YELLOW[!]$RESET Install symbolic link '$BLUE$SCRIPT_DIR/arm-run$RESET'"
        ln -sf "$SCRIPT_DIR/docker-run" "$SCRIPT_DIR/arm-run"
        chmod +x "$SCRIPT_DIR/arm-run"
    else
        echo -e "$YELLOW[$GREEN!$YELLOW]$RESET Symbolic links '$BLUE$SCRIPT_DIR/arm-run$RESET' already present."
    fi

    if [ ! -f "$SCRIPT_DIR/arm8-run" ]; then
        echo -e "$YELLOW[!]$RESET Install symbolic link '$BLUE$SCRIPT_DIR/arm8-run$RESET'"
        ln -sf "$SCRIPT_DIR/docker-run" "$SCRIPT_DIR/arm8-run"
        chmod +x "$SCRIPT_DIR/arm8-run"
    else
        echo -e "$YELLOW[$GREEN!$YELLOW]$RESET Symbolic links '$BLUE$SCRIPT_DIR/arm8-run$RESET' already present."
    fi
    exit 0
fi

# Remove quotes
unquote() {
    VALUE="$@"
    if [ -z "$(echo $VALUE | cut -f1 -d"'")" ]; then
        echo $(echo $VALUE | cut -f2- -d"'" | rev | cut -f2- -d"'" | rev)
    elif [ -z "$(echo $VALUE | cut -f1 -d'"')" ]; then
        echo $(echo $VALUE | cut -f2- -d'"' | rev | cut -f2- -d'"' | rev)
    else
        echo $@
    fi
}

# Yaml parser to XPath
parse_yaml() {
    FILENAME=$1

    if [ -z "$FILENAME" ]; then
        echo -e "${RED}Abort:$RESET No file specified"
        exit 1
    fi

    PREV_INDENT=0
    XPATH=""
    LAST_XPATH=""

    while IFS= read -r line; do
        INDENT=0

        STRIPPED="$(echo $line)"
        if [[ "$STRIPPED" =~ ^-.* ]]; then
            ITEM="$(echo $(echo $STRIPPED | cut -f2- -d'-'))"
            echo "$LAST_XPATH=$(unquote $ITEM)"
        else
            # Get indentation level
            while [ -z "$(echo "$line" | cut -f$((INDENT + 1)) -d' ')" ]; do
                INDENT=$(($INDENT + 1))
            done

            if [ $INDENT -ne $PREV_INDENT ]; then
                # Remove last part
                if [ $INDENT -lt $PREV_INDENT ]; then
                    XPATH=$(echo $XPATH | rev | cut -f2- -d'.' | rev)
                elif [ $INDENT -gt $PREV_INDENT ]; then
                    XPATH=$LAST_XPATH
                fi
                PREV_INDENT=$INDENT
            fi

            LABEL="$(echo $line | cut -f1 -d':')"
            VALUE="$(echo $(echo $line | cut -f2- -d':'))"
            if [ ! -z "$VALUE" ]; then
                echo "${XPATH}.${LABEL}=$(unquote $VALUE)"
            fi
            LAST_XPATH="${XPATH}.${LABEL}"
        fi
    done < <(cat $FILENAME)
}

# Since we utilize the symlink arm-run to execute commands in an armv7
# environment, we check for the executable name to determine the container
# to use.
NAME=$(basename $0)

# Initialize variables
WORKDIR=$(pwd)
CUR_DIR=$(pwd)

# Use bake for better performance
export COMPOSE_BAKE=true

# Detect git repository root
while [ ! -z "${CUR_DIR}" ] && [ ! -d "${CUR_DIR}/.git" ]; do
    CUR_DIR=$(dirname ${CUR_DIR})
done

# Get directory containing given file
locate_file() {
    if [ -f "$CUR_DIR/.devcontainer/$1" ]; then
        echo "$CUR_DIR/.devcontainer"
    elif [ -f "$CUR_DIR/local/$1" ]; then
        echo "$CUR_DIR/local"
    elif [ -f "$CUR_DIR/$1" ]; then
        echo "$CUR_DIR"
    elif [ -f "$WORKDIR/$1" ]; then
        echo "$WORKDIR"
    fi
}

DOCKER_COMPOSE_DIR="$(locate_file docker-compose.yml)"
if [ ! -z "$DOCKER_COMPOSE_DIR" ]; then
    echo -e "$YELLOW[!]$RESET Use ${GREEN}docker-compose.yml${RESET} in $BLUE$DOCKER_COMPOSE_DIR$RESET"
elif [ -f "$HOME/.local/share/docker-run/docker-compose.yml" ]; then
    DOCKER_COMPOSE_DIR="$HOME/.local/share/docker-run"
    echo -e "$YELLOW[!]$RESET Use ${GREEN}docker-compose.yml${RESET} in $BLUE$DOCKER_COMPOSE_DIR$RESET"
else
    echo -e "$RED[E]$RESET Unable to locate '${BLUE}docker-compose.yml$RESET'" >&2
    exit 1
fi
CONTAINER_NAME="$(basename $WORKDIR)"

COMMANDS_DIR="$(locate_file .commands)"
if [ ! -z "$COMMANDS_DIR" ]; then
    echo -e "$YELLOW[!]$RESET Use ${GREEN}.commands${RESET} in $BLUE$COMMANDS_DIR$RESET"
else
    if [ -f "$HOME/.local/share/docker-run/.commands" ]; then
        GLOBAL_COMMANDS_DIR="$HOME/.local/share/docker-run"
        echo -e "$YELLOW[!]$RESET Use ${GREEN}.commands${RESET} in ${BLUE}$GLOBAL_COMMANDS_DIR${RESET}"
    fi
fi

USER_COMMANDS_DIR="$(locate_file .user-commands)"
if [ ! -z "$USER_COMMANDS_DIR" ]; then
    echo -e "$YELLOW[!]$RESET Use ${GREEN}.user-commands${RESET} in $BLUE$USER_COMMANDS_DIR$RESET"
fi

# Specify compose target platform
if [ "$NAME" == "arm-run" ]; then
    DOCKER_COMPOSE_PLATFORM="linux/arm/v7"
elif [ "$NAME" == "arm8-run" ]; then
    DOCKER_COMPOSE_PLATFORM="linux/arm64/v8"
else
    DOCKER_COMPOSE_PLATFORM="linux/amd64"
fi

DOCKER_COMPOSE_TARGET=$(parse_yaml "$DOCKER_COMPOSE_DIR/docker-compose.yml" | grep platform | grep $DOCKER_COMPOSE_PLATFORM | cut -f3 -d'.')

GIT_DIR=$CUR_DIR
GIT_BASENAME=$(echo "P$GIT_DIR" | sed 's/\//-/g' | tr '[:upper:]' '[:lower:]')

CONTAINER_ID=$(docker container ls | grep "$GIT_BASENAME-$DOCKER_COMPOSE_TARGET" | cut -f1 -d' ')
if [ ! -z "$CONTAINER_ID" ]; then
    if [ ! -z "$1" ] && [ "$1" == "stop" ]; then
        echo -e "$YELLOW[!]$RESET Stop running container $BLUE$CONTAINER_ID$RESET"
        docker stop $CONTAINER_ID &>/dev/null
        exit $?
    elif [ ! -z "$1" ] && [ "$1" == "rebuild" ]; then
        echo -e "$YELLOW[!]$RESET Stop running container $BLUE$CONTAINER_ID$RESET"
        docker stop $CONTAINER_ID &>/dev/null
    elif [ ! -f "/tmp/docker-run/sock" ]; then
        echo -e "$YELLOW[!]$RESET Stop running container $BLUE$CONTAINER_ID$RESET"
        docker stop $CONTAINER_ID &>/dev/null
    else
        DIR="$(parse_yaml /tmp/docker-run/sock | grep "$DOCKER_COMPOSE_PLATFORM-$DOCKER_COMPOSE_TARGET-$GIT_BASENAME=" | cut -f2- -d'=')"
        if [ -z "$DIR" ] || [ "$DIR" != "$GIT_DIR" ]; then
            echo -e "$YELLOW[!]$RESET Stop running container $BLUE$CONTAINER_ID$RESET"
            docker stop $CONTAINER_ID &>/dev/null
        fi
    fi
elif [ ! -z "$1" ] && [ "$1" == "stop" ]; then
    echo -e "$YELLOW[!]$RESET No container running."
    exit 0
fi

if [ ! -z "$1" ] && [ "$1" == "rebuild" ]; then
    CONTAINER_ID=$(docker container ls -a | grep "$GIT_BASENAME-$DOCKER_COMPOSE_TARGET" | cut -f1 -d' ')
    if [ ! -z "$CONTAINER_ID" ]; then
        echo -e "$YELLOW[!]$RESET Run: '${BLUE}docker container rm $CONTAINER_ID$RESET'"
        docker container rm $CONTAINER_ID 1>/dev/null || exit 1
    fi

    echo -e "$YELLOW[!]$RESET Run: '${BLUE}GIT_DIR="$GIT_DIR" docker compose -f \"$DOCKER_COMPOSE_DIR/docker-compose.yml\" -p \"$GIT_BASENAME\" build --no-cache $DOCKER_COMPOSE_TARGET$RESET'"
    (cd $GIT_DIR && GIT_DIR="$GIT_DIR" docker compose -f "$DOCKER_COMPOSE_DIR/docker-compose.yml" -p "$GIT_BASENAME" build --no-cache $DOCKER_COMPOSE_TARGET) && exit 0 || exit 1
fi

# Get Git branch
REGEX="([A-Z]+-[0-9]+)"
BRANCH="$(/usr/bin/git branch --show-current)"

if [[ $BRANCH =~ $REGEX ]]; then
    BUILD_DIR="${BASH_REMATCH[1]}"
else
    BUILD_DIR=$(echo "${BRANCH}" | tr '[:upper:]' '[:lower:]' | sed 's/[\/_]/-/g')
fi

if [ ! -f "/tmp/docker-run/sock" ]; then
    echo "$DOCKER_COMPOSE_PLATFORM-$DOCKER_COMPOSE_TARGET-$GIT_BASENAME: $GIT_DIR" >> /tmp/docker-run/sock
else
    cat /tmp/docker-run/sock | grep -v "$DOCKER_COMPOSE_PLATFORM-$DOCKER_COMPOSE_TARGET-$GIT_BASENAME:" > /tmp/docker-run/sock.tmp
    mv /tmp/docker-run/sock.tmp /tmp/docker-run/sock
    echo "$DOCKER_COMPOSE_PLATFORM-$DOCKER_COMPOSE_TARGET-$GIT_BASENAME: $GIT_DIR" >> /tmp/docker-run/sock
fi

# Get container id
CONTAINER_ID=$(docker container ls | grep "$GIT_BASENAME-$DOCKER_COMPOSE_TARGET" | cut -f1 -d' ')

# Abort if container isn't running
if [ -z "$CONTAINER_ID" ]; then
    if [ $? -ne 0 ]; then
        echo -e "$RED[E]$RESET Failed to run '${BLUE}docker run --rm --privileged multiarch/qemu-user-static --reset -p yes$RESET'"
        exit 1
    fi
    docker run --rm --privileged multiarch/qemu-user-static --reset -p yes &>/dev/null

    echo -en "$YELLOW[!]$RESET Run: '${BLUE}GIT_DIR="$GIT_DIR" docker compose -f \"$DOCKER_COMPOSE_DIR/docker-compose.yml\" -p \"$GIT_BASENAME\" up -d \"$DOCKER_COMPOSE_TARGET\"$RESET'"
    SECONDS=0
    while IFS= read -r line; do
        echo -en "\r$YELLOW[!]$RESET Run: '${BLUE}GIT_DIR="$GIT_DIR" docker compose -f \"$DOCKER_COMPOSE_DIR/docker-compose.yml\" -p \"$GIT_BASENAME\" up -d \"$DOCKER_COMPOSE_TARGET\"$RESET' ${SECONDS}s    "
    done < <(cd $GIT_DIR && GIT_DIR="$GIT_DIR" docker compose -f "$DOCKER_COMPOSE_DIR/docker-compose.yml" -p "$GIT_BASENAME" up -d $DOCKER_COMPOSE_TARGET 2>&1)
    echo ""
    if [ $? -ne 0 ]; then
        echo -e "$RED[!]$RESET Failed to run: '${BLUE}GIT_DIR="$GIT_DIR" docker compose -f \"$DOCKER_COMPOSE_DIR/docker-compose.yml\" -p \"$GIT_BASENAME\" up -d \"$DOCKER_COMPOSE_TARGET\"$RESET'"
        exit 1
    fi
fi

CONTAINER_ID=$(docker container ls | grep "$GIT_BASENAME-$DOCKER_COMPOSE_TARGET" | cut -f1 -d' ')
echo -e "$YELLOW[!]$RESET Use ${GREEN}container id${RESET}: '$BLUE$CONTAINER_ID$RESET'"

# Detect relative path from repository root
if [ ! -z ${CUR_DIR} ]; then
    CUR_DIR="${WORKDIR##${CUR_DIR}}"
fi

run_command() {
    OUTPUT=0
    COLOR="${COLORS[$COLOR_SELECTION]}"
    eval set -- "${line#"CMD:"}"
    echo ""

    # Executable header
    echo -e "$COLOR┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────────$RESET"
    echo -e "$COLOR│$RESET ${YELLOW}Run:$RESET '$BLUE$@$RESET'"
    ENV_CHECK="${ENV_ARGS_BARE[@]}"
    if [ ! -z "${ENV_CHECK}" ]; then
        echo -e "$COLOR│$RESET ${YELLOW}Environment:$RESET'"
        for ENV in "${ENV_ARGS_BARE[@]}"; do
            echo -e "$COLOR│$RESET ${YELLOW}    -$RESET $BLUE${ENV}$RESET"
        done
    fi
    if [ ! -z "${CUR_DIR}" ]; then
        echo -e "$COLOR│$RESET ${YELLOW}Working Directory:$RESET '$BLUE/git/${CUR_DIR}$RESET'"
    fi
    if [ ! -z "$INTERACTIVE" ] && [ "$INTERACTIVE" == "YES" ]; then
        echo -e "$COLOR│$RESET ${YELLOW}Interactive Mode:$RESET '${BLUE}YES$RESET'"
        SECONDS=0
        echo -e "\r$COLOR└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────$RESET"
        trap '' SIGINT
        eval "docker exec -e \"TZ=Europe/Berlin\" ${ENV_ARGS[@]} --workdir \"/git/$CUR_DIR\" -it $CONTAINER_ID $(printf '%q ' "$@")"
        EXIT_CODE=$?
        trap - SIGINT
        echo -e "\r$COLOR┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────────$RESET"
        echo -e "\r$COLOR│$RESET ${COLOR}Duration:${RESET} $SECONDS                                                                                             "
        echo -e "\r$COLOR└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────$RESET"
    else
        LOG_FILE="$(mktemp -p /tmp/docker-run/)"
        echo -e "$COLOR│$RESET ${YELLOW}Logfile:$RESET '$BLUE$LOG_FILE$RESET'"
        echo -e "$COLOR└───┬────────────────────────────────────────────────────────────────────────────────────────────────────────────────$RESET"
        echo -en "\r    $COLOR│$RESET "

        # Handle output
        local output_line_no=0
        local last_output_line_no=99
        local output_lines=()
        local max_output_lines=8

        SECONDS=0
        trap '' SIGINT
        while IFS= read full_line; do
            NUM_COLS=$(tput cols)
            NUM_COLS=$(($NUM_COLS - 7))

            full_line="$(echo -en "$full_line")"
            new_line="${full_line:0:$NUM_COLS}"
            full_line="${full_line:$NUM_COLS}"

            while [ ! -z "$new_line" ]; do
                OUTPUT=1

                OUTPUT_CONTENT=""
                # Reprint last n-1 lines
                if [ $output_line_no -ne $last_output_line_no ]; then
                    if [ $output_line_no -gt 0 ]; then
                        for line_index in $(seq $((output_line_no - 1))); do
                            OUTPUT_CONTENT="$OUTPUT_CONTENT\033[F"
                        done
                        for output_line in "${output_lines[@]}"; do
                            length=${#output_line}
                            empty_string="$(printf '%*s' "$length" '')"
                            OUTPUT_CONTENT="$OUTPUT_CONTENT\r    $COLOR│$RESET $empty_string\n"
                        done
                        if [ $output_line_no -gt $(($max_output_lines - 1)) ]; then
                            output_lines=("${output_lines[@]:1}")
                            output_line_no=$max_output_lines
                        fi
                        for line_index in $(seq $output_line_no); do
                            OUTPUT_CONTENT="$OUTPUT_CONTENT\033[F\r"
                        done
                        for output_line in "${output_lines[@]}"; do
                            OUTPUT_CONTENT="$OUTPUT_CONTENT\r    $COLOR│$RESET $output_line\n"
                        done
                        OUTPUT_CONTENT="$OUTPUT_CONTENT\r    $COLOR│$RESET "
                    fi
                    last_output_line_no=$output_line_no
                fi

                if [ ! -z "$new_line" ]; then
                    OUTPUT_CONTENT="$OUTPUT_CONTENT\r    $COLOR│$RESET $new_line"
                    output_lines+=("$new_line")
                    if [ $output_line_no -lt $(($max_output_lines)) ]; then
                        output_line_no=$(($output_line_no + 1))
                    else
                        last_output_line_no=0
                    fi
                else
                    OUTPUT_CONTENT="$OUTPUT_CONTENT\r    $COLOR│$RESET                                                                                               "
                fi
                echo -ne "$OUTPUT_CONTENT\r"

                new_line="${full_line:0:$NUM_COLS}"
                full_line="${full_line:$NUM_COLS}"
            done

            new_line=""
            full_line=""
        done < <(docker exec -e "TZ=Europe/Berlin" ${ENV_ARGS[@]} --workdir "/git/$CUR_DIR" $CONTAINER_ID "$@" 2>&1)

        EXIT_CODE=${PIPESTATUS[0]}
        CMD="$@"
        EXEC_PID=$(echo $(docker top $CONTAINER_ID | grep "$CMD" | grep -v grep) | cut -f2 -d' ')
        if [ ! -z "$EXEC_PID" ]; then
            kill -2 $EXEC_PID
            EXIT_CODE=2
        fi
        trap - SIGINT

        # Executable footer
        if [ $OUTPUT -eq 1 ]; then
            echo -e "\r$COLOR    ├────────────────────────────────────────────────────────────────────────────────────────────────────────────────$RESET"
        fi
        echo -e "\r$COLOR    │$RESET ${COLOR}Duration:${RESET} $SECONDS                                                                                             "
        echo -e "\r$COLOR    └────────────────────────────────────────────────────────────────────────────────────────────────────────────────$RESET"
    fi

    # Change color for next command
    COLOR_SELECTION=$(($COLOR_SELECTION + 1))
    if [ $COLOR_SELECTION -eq 3 ]; then
        COLOR_SELECTION=0
    fi
}

if [ ! -z "$1" ]; then
    INPUT=""

    if [ ! -z "$GLOBAL_COMMANDS_DIR" ]; then
        INPUT="$GLOBAL_COMMANDS_DIR/.commands"
        REPOSITORY="$GIT_DIR"
    fi

    if [ ! -z "$COMMANDS_DIR" ]; then
        INPUT="$COMMANDS_DIR/.commands"
    fi

    if [ ! -z "$USER_COMMANDS_DIR" ]; then
        INPUT="$USER_COMMANDS_DIR/.user-commands"
    fi

    CMD_EXECUTED=0
    ENV_ARGS=()
    ENV_ARGS_BARE=()
    COLORS=("$CYAN" "$YELLOW" "$GREEN")
    COLOR_SELECTION=0
    while IFS= read -u 10 line; do
        if [ ! -z "$line" ]; then
            if [[ "$line" =~ ^ENV:.* ]]; then
                ENV_ARGS+=("-e ${line#"ENV:"}")
                ENV_ARGS_BARE+=("${line#"ENV:"}")
            elif [[ "$line" =~ ^DIR:.* ]]; then
                CUR_DIR="$(echo ${line#"DIR:"})"
            elif [[ "$line" =~ ^INTERACTIVE:.* ]]; then
                INTERACTIVE="$(echo ${line#"INTERACTIVE:"})"
            elif [[ "$line" =~ ^CMD:.* ]]; then
                run_command
                CMD_EXECUTED=1
            else
                echo""
                echo -e "${RED}[!]${RESET} Invalid input: '${RED}$line${RESET}'."
            fi
        fi
    done 10< <("$INPUT" "$REPOSITORY" "$DOCKER_COMPOSE_TARGET" "$1" 2>/dev/null)

    if [ $CMD_EXECUTED -eq 0 ]; then
        # Run given commandline in the container
        OUTPUT=0
        COLOR="$BLUE"

        echo -e "$COLOR┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────────$RESET"
        echo -e "$COLOR│$RESET ${YELLOW}Run:$RESET '$BLUE$@$RESET'"
        ENV_CHECK="${ENV_ARGS_BARE[@]}"
        if [ ! -z "${ENV_CHECK}" ]; then
            echo -e "$COLOR│$RESET ${YELLOW}Environment:$RESET'"
            for ENV in "${ENV_ARGS_BARE[@]}"; do
                echo -e "$COLOR│$RESET ${YELLOW}    -$RESET $BLUE${ENV}$RESET"
            done
        fi
        if [ ! -z "${CUR_DIR}" ]; then
            echo -e "$COLOR│$RESET ${YELLOW}Working Directory:$RESET '$BLUE/git/${CUR_DIR}$RESET'"
        fi
        echo -e "$COLOR└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────$RESET"
        eval "docker exec -e \"TZ=Europe/Berlin\" ${ENV_ARGS[@]} --workdir \"/git/$CUR_DIR\" -it $CONTAINER_ID $(printf '%q ' "$@")"
    else
        echo ""
    fi
else
    echo -e "${RED}[!]${RESET} No command specified."
fi
