#!/bin/bash
#
# Requirements:
#  - Executable script `.commands` in the root of the GIT repository
#      The script has to write up to two lines into stdout
#        1. The first line is the command to execute inside the docker container
#        2. The second line has to be the relative path to the working directory
#      E.g. to execute `ls` inside the `$GIT_ROOT/build` directory, the script has to return
#        ```
#          "ls"
#          "./build"
#        ```
# - A `docker-compose.yml` has to be located in the `$GIT_ROOT` or inside `$GIT_ROOT/local` and
#   has to configure three services for full support, each one specifying a different platform:
#     * `linux/amd64`
#     * `linux/arm/v7`
#     * `linux/arm64/v8`
# 
# Afterwards, simply create two symbolic links `arm-run` and `arm8-run` or simply use 
# `docker-run install-links` and be ready to run any command in an armv7, armv8 or amd64
# docker environment, using e.g. `docker-run ls`
#
# At runtime the information about running docker containers managed by the script is located
# at /tmp/docker-run

RED="\e[31m"
GREEN="\e[32m"
YELLOW="\e[33m"
BLUE="\e[34m"
RESET="\e[0m"

# Install symbolic links
if [ "$1" == "install-links" ]; then
    SCRIPT_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd)
    if [ ! -f "$SCRIPT_DIR/arm-run" ]; then
        echo -e "$YELLOW[!]$RESET Install symbolic link '$BLUE$SCRIPT_DIR/arm-run$RESET'"
        ln -sf "$SCRIPT_DIR/docker-run" "$SCRIPT_DIR/arm-run"
        chmod +x "$SCRIPT_DIR/arm-run"
    elif [ ! -f "$SCRIPT_DIR/arm8-run" ]; then
        echo -e "$YELLOW[!]$RESET Install symbolic link '$BLUE$SCRIPT_DIR/arm8-run$RESET'"
        ln -sf "$SCRIPT_DIR/docker-run" "$SCRIPT_DIR/arm8-run"
        chmod +x "$SCRIPT_DIR/arm8-run"
    else
        echo -e "$YELLOW[$GREEN!$YELLOW]$RESET Symbolic links '$BLUE$SCRIPT_DIR/arm-run$RESET' and '$BLUE$SCRIPT_DIR/arm8-run$RESET' already present."
    fi
    exit 0
fi

# Remove quotes
unquote() {
    VALUE="$@"
    if [ -z "$(echo $VALUE | cut -f1 -d"'")" ]; then
        echo $(echo $VALUE | cut -f2- -d"'" | rev | cut -f2- -d"'" | rev)
    elif [ -z "$(echo $VALUE | cut -f1 -d'"')" ]; then
        echo $(echo $VALUE | cut -f2- -d'"' | rev | cut -f2- -d'"' | rev)
    else
        echo $@
    fi
}

# Yaml parser to XPath
parse_yaml() {
    FILENAME=$1

    if [ -z "$FILENAME" ]; then
        echo -e "${RED}Abort:$RESET No file specified"
        exit 1
    fi

    PREV_INDENT=0
    XPATH=""
    LAST_XPATH=""

    while IFS= read -r line; do
        INDENT=0

        STRIPPED="$(echo $line)"
        if [[ "$STRIPPED" =~ ^-.* ]]; then
            ITEM="$(echo $(echo $STRIPPED | cut -f2- -d'-'))"
            echo "$LAST_XPATH=$(unquote $ITEM)"
        else
            # Get indentation level
            while [ -z "$(echo "$line" | cut -f$((INDENT + 1)) -d' ')" ]; do
                INDENT=$(($INDENT + 1))
            done

            if [ $INDENT -ne $PREV_INDENT ]; then
                # Remove last part
                if [ $INDENT -lt $PREV_INDENT ]; then
                    XPATH=$(echo $XPATH | rev | cut -f2- -d'.' | rev)
                elif [ $INDENT -gt $PREV_INDENT ]; then
                    XPATH=$LAST_XPATH
                fi
                PREV_INDENT=$INDENT
            fi

            LABEL="$(echo $line | cut -f1 -d':')"
            VALUE="$(echo $(echo $line | cut -f2- -d':'))"
            if [ ! -z "$VALUE" ]; then
                echo "${XPATH}.${LABEL}=$(unquote $VALUE)"
            fi
            LAST_XPATH="${XPATH}.${LABEL}"
        fi
    done < <(cat $FILENAME)
}

# Since we utilize the symlink arm-run to execute commands in an armv7
# environment, we check for the executable name to determine the container
# to use.
NAME=$(basename $0)

# Initialize variables
WORKDIR=$(pwd)
CUR_DIR=$(pwd)

# Use bake for better performance
export COMPOSE_BAKE=true

# Detect git repository root
while [ ! -z "${CUR_DIR}" ] && [ ! -d "${CUR_DIR}/.git" ]; do
    CUR_DIR=$(dirname ${CUR_DIR})
done

# Get directory containing given file
locate_file() {
    if [ -f "$CUR_DIR/.devcontainer/$1" ]; then
        echo "$CUR_DIR/.devcontainer"
    elif [ -f "$CUR_DIR/local/$1" ]; then
        echo "$CUR_DIR/local"
    elif [ -f "$CUR_DIR/$1" ]; then
        echo "$CUR_DIR"
    elif [ -f "$WORKDIR/$1" ]; then
        echo "$WORKDIR"
    else
        echo -e "$RED[E]$RESET Unable to locate '${BLUE}$1$RESET'"
        exit 1
    fi
}

DOCKER_COMPOSE_DIR="$(locate_file docker-compose.yml)"
echo -e "$YELLOW[!]$RESET Use docker-compose.yml in $BLUE$DOCKER_COMPOSE_DIR$RESET"
CONTAINER_NAME="$(basename $WORKDIR)"

# Specify compose target platform
if [ "$NAME" == "arm-run" ]; then
    DOCKER_COMPOSE_PLATFORM="linux/arm/v7"
elif [ "$NAME" == "arm8-run" ]; then
    DOCKER_COMPOSE_PLATFORM="linux/arm64/v8"
else
    DOCKER_COMPOSE_PLATFORM="linux/amd64"
fi

DOCKER_COMPOSE_TARGET=$(parse_yaml "$DOCKER_COMPOSE_DIR/docker-compose.yml" | grep platform | grep $DOCKER_COMPOSE_PLATFORM | cut -f3 -d'.')

GIT_DIR=$CUR_DIR
GIT_BASENAME=$(echo "P$GIT_DIR" | sed 's/\//-/g' | tr '[:upper:]' '[:lower:]')

CONTAINER_ID=$(docker container ls | grep "$GIT_BASENAME-$DOCKER_COMPOSE_TARGET" | cut -f1 -d' ')
if [ ! -z "$CONTAINER_ID" ]; then
    if [ ! -f "/tmp/docker-run" ]; then
        echo -e "$YELLOW[!]$RESET Stop running container $BLUE$CONTAINER_ID$RESET"
        docker stop $CONTAINER_ID &>/dev/null
    else
        DIR="$(parse_yaml /tmp/docker-run | grep "$DOCKER_COMPOSE_PLATFORM-$DOCKER_COMPOSE_TARGET-$GIT_BASENAME=" | cut -f2- -d'=')"
        if [ -z "$DIR" ] || [ "$DIR" != "$GIT_DIR" ]; then
            echo -e "$YELLOW[!]$RESET Stop running container $BLUE$CONTAINER_ID$RESET"
            docker stop $CONTAINER_ID &>/dev/null
        fi
    fi
fi

if [ ! -z "$1" ] && [ "$1" == "rebuild" ]; then
    echo -e "$YELLOW[!]$RESET Run: '${BLUE}docker compose -p \"$GIT_BASENAME\" build --no-cache $DOCKER_COMPOSE_TARGET$RESET'"
    (cd $DOCKER_COMPOSE_DIR && docker compose -p "$GIT_BASENAME" build --no-cache $DOCKER_COMPOSE_TARGET) && exit 0 || exit 1
fi

# Get Git branch
REGEX="([A-Z]+-[0-9]+)"
BRANCH="$(/usr/bin/git branch --show-current)"

if [[ $BRANCH =~ $REGEX ]]; then
    BUILD_DIR="${BASH_REMATCH[1]}"
else
    BUILD_DIR=$(echo "${BRANCH}" | tr '[:upper:]' '[:lower:]' | sed 's/[\/_]/-/g')
fi

if [ ! -f "/tmp/docker-run" ]; then
    echo "$DOCKER_COMPOSE_PLATFORM-$DOCKER_COMPOSE_TARGET-$GIT_BASENAME: $GIT_DIR" >> /tmp/docker-run
else
    cat /tmp/docker-run | grep -v "$DOCKER_COMPOSE_PLATFORM-$DOCKER_COMPOSE_TARGET-$GIT_BASENAME:" > /tmp/docker-run-tmp
    mv /tmp/docker-run-tmp /tmp/docker-run
    echo "$DOCKER_COMPOSE_PLATFORM-$DOCKER_COMPOSE_TARGET-$GIT_BASENAME: $GIT_DIR" >> /tmp/docker-run
fi

# Get container id
CONTAINER_ID=$(docker container ls | grep "$GIT_BASENAME-$DOCKER_COMPOSE_TARGET" | cut -f1 -d' ')

# Abort if container isn't running
if [ -z "$CONTAINER_ID" ]; then
    if [ $? -ne 0 ]; then
        echo -e "$RED[E]$RESET Failed to run '${BLUE}docker run --rm --privileged multiarch/qemu-user-static --reset -p yes$RESET'"
        exit 1
    fi
    docker run --rm --privileged multiarch/qemu-user-static --reset -p yes &>/dev/null

    echo -en "$YELLOW[!]$RESET Run: '${BLUE}docker compose -p "$GIT_BASENAME" up -d $DOCKER_COMPOSE_TARGET$RESET'"
    start_time=$(date +%s)
    while IFS= read -r line; do
        curr_time=$(date +%s)
        echo -en "\r$YELLOW[!]$RESET Run: '${BLUE}docker compose -p "$GIT_BASENAME" up -d $DOCKER_COMPOSE_TARGET$RESET' $(($curr_time - $start_time))s"
    done < <(cd $DOCKER_COMPOSE_DIR && docker compose -p "$GIT_BASENAME" up -d $DOCKER_COMPOSE_TARGET 2>1)
    echo ""
    if [ $? -ne 0 ]; then
        echo -e "$RED[E]$RESET Failed to run '${BLUE}docker compose -p \"$GIT_BASENAME\" up -d$RESET'"
        exit 1
    fi
fi

CONTAINER_ID=$(docker container ls | grep "$GIT_BASENAME-$DOCKER_COMPOSE_TARGET" | cut -f1 -d' ')
echo -e "$YELLOW[!]$RESET Use container: '$BLUE$CONTAINER_ID$RESET'"

# Detect relative path from repository root
if [ ! -z ${CUR_DIR} ]; then
    CUR_DIR="${WORKDIR##${CUR_DIR}}"
fi

if [ ! -z "$1" ]; then
    while IFS= read -r line; do
        if [ -z "$CMD" ]; then
            CMD="$line"
        else
            CUSTOM_DIR="$line"
        fi
    done < <($GIT_DIR/.commands $DOCKER_COMPOSE_TARGET $1 2>/dev/null)
    if [ $? -eq 0 ] && [ ! -z "$CMD" ]; then
        echo -e "$YELLOW[!]$RESET Run: '${BLUE}$CMD$RESET'"
        docker exec -e "TZ=Europe/Berlin" --workdir "/git/$CUSTOM_DIR" -it $CONTAINER_ID $CMD
        exit $?
    fi
fi

# Run given commandline in the container
echo -e "$YELLOW[!]$RESET Run: '$BLUE$@$RESET'"
docker exec -e "TZ=Europe/Berlin" --workdir "/git$CUR_DIR" -it $CONTAINER_ID $@
